

## Motivation & Direction

This UI is the **primary frontend** for all Platform and Application capabilities in Atlas.

The goal is to enable fast, reliable iteration (“vibecoding”) without UI chaos by using a small set of reusable primitives that can render many data objects consistently.

### Core direction
- **One UI for everything**: all apps surface their objects through the same frontend.
- **Reuse over customization**: apps don’t invent UI patterns; they configure platform primitives.
- **Data-object driven rendering**: views adapt to the schema/shape of the data object (columns, fields, types, labels), so adding a new object type should require minimal UI work.
- **Robust error handling**: failures must be visible, actionable, and easy to debug.

### Non-goals (for now)
- Pixel-perfect custom layouts per app
- App-specific UI component libraries
- “Magic” UI that guesses intent without explicit contracts

### Vibecoding support (debuggability)
The platform provides standardized:
- API error rendering (clear message + details)
- request/response logging (inspectable in the UI)
- fallback placeholders for unsupported/invalid view configs


## **Initial set**

- **TableView**
    - Primary representation for collections
    - Sorting, filtering, pagination
    - Canonical source for most visualizations

- **RowActions**
    - Fixed action slot per table row (right-aligned)
    - Canonical actions:
        - Delete (destructive, platform-owned)
        - Special (context-dependent: Edit | Copy | etc.)
    - Apps may configure behavior, not layout

- **DetailView*
    - Inspect a single object
    - Read-only by default
    - Linked from TableView
        
- **LineChart**
    - Time-based trends
    - Always derived from table data
        
- **BarChart**
    - Category comparison / distributions
    - Preferred over pie charts
    

**Optional (later)**
- MetricTiles *(*KPIs, counters)
    
**Explicitly out of scope**
- Pie charts
- Custom canvases
- Free-form layouts
- App-defined chart types
---

### Design Rules

- All charts are **derived from Table datasets**
- Charts = _view + mapping_, not separate data models
- No custom UI components inside apps
- UI primitives are reused everywhere  
    Repetition is intentional.
---

### Failure & Fallback Behavior

If an app requests:
- an unsupported view type, or
- an invalid configuration

The Platform must:
1. Render a **warning placeholder**
2. Explain why it’s unsupported
3. Suggest the closest supported alternative
4. Log the event as a **platform gap**
5. 
This feedback loop drives platform evolution.

---

### LLM Interaction Model

The UI system is designed to be
- Easy for an LLM to remember
- Hard for an LLM to violate
- Trainable via examples

Documentation is treated as
- executable guidance
- prompt reinforcement
- part of the platform surface
---

### Implementation Direction

- Web-based UI (React)
- Reusable primitives: tables, simple charts, object detail views
- Start with the **Workout app**, then abstract
- Use **mainstream React + API patterns** on purpose
- Clear separation of:
    - data models
    - view components
    - state/logic (hooks/controllers)
        
- Explicit, stable **API contracts** to minimize frontend/backend friction
### Tech stack

- **Frontend:** React + TypeScript + Vite
- **Routing:** React Router (optional until you have >1 page)
- **HTTP:** `fetch` wrapper (platform-owned)
- **State:** local component state first; add a store later only if needed

### Data flow

Add a short contract like:

- UI talks to backend via **HTTP JSON API**
- UI never touches DB directly
- Platform owns:
    - base URL configuration
    - error handling
    - request logging (debug)
        
- Apps provide:
    - endpoint paths + typed DTOs (TypeScript types)
        

### How data “reaches” the UI in practice

Two standard approaches:

1. **List endpoint → table**  
    UI calls `GET /api/<object>` and renders rows.
    
2. **Mutation endpoint → refresh**  
    UI calls `POST/PUT/DELETE`, then re-fetches list (simple, reliable MVP).